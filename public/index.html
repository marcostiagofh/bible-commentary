<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Comentário Bíblico — Navegador Local</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  /* small custom tweaks */
  .book-item:hover { background: rgba(255,255,255,0.03); }
  .chapter-item:hover { background: rgba(255,255,255,0.03); }
  .file-item:hover { background: rgba(255,255,255,0.03); }
  pre { white-space: pre-wrap; }
  /* Estilo para a frase destacada durante a leitura */
  .highlight-speech {
    background-color: rgba(96, 165, 250, 0.5); /* Azul claro semi-transparente */
    transition: background-color 0.2s ease-in-out;
  }
  /* Estilos para barras de rolagem mais discretas (WebKit) */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }
  ::-webkit-scrollbar-track {
    background: transparent;
  }
  ::-webkit-scrollbar-thumb {
    background-color: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
  }
  ::-webkit-scrollbar-thumb:hover {
    background-color: rgba(255, 255, 255, 0.4);
  }
</style>
<body class="bg-gray-900 text-gray-100 font-sans p-4">
  <div class="flex flex-col md:flex-row md:h-screen md:max-h-screen gap-4">
    <!-- Coluna de Livros -->
    <div class="flex-shrink-0 md:flex-none md:w-64 bg-gray-800 p-4 rounded-lg flex flex-col">
      <h2 class="text-xl font-bold mb-4">Livros</h2>
      <input id="filterBook" placeholder="filtrar livros..." class="w-full p-2 mb-3 text-gray-900 rounded" />
      <div id="books" class="space-y-1 overflow-y-auto h-32 md:h-auto md:flex-1"></div>
    </div>
    <!-- Coluna de Capítulos -->
    <div class="flex-shrink-0 md:flex-none md:w-64 bg-gray-800 p-4 rounded-lg flex flex-col">
      <h2 class="text-xl font-bold mb-4">Capítulos</h2>
      <div id="chapters" class="space-y-1 overflow-y-auto h-32 md:h-auto md:flex-1"></div>
    </div>
    <!-- Coluna de Trechos -->
    <div class="flex-shrink-0 md:flex-none md:w-64 bg-gray-800 p-4 rounded-lg flex flex-col">
      <h2 class="text-xl font-bold mb-4">Trechos / Arquivos</h2>
      <div id="files" class="space-y-1 overflow-y-auto h-32 md:h-auto md:flex-1"></div>
    </div>

    <!-- Área de Leitura (ocupa o resto do espaço) -->
    <main class="flex-1 bg-gray-800 p-4 rounded-lg flex flex-col overflow-hidden">
      <div class="flex flex-col sm:flex-row justify-between items-start mb-2 gap-4">
        <div>
          <h2 id="readerTitle" class="text-2xl font-bold">Selecione um trecho</h2>
          <p id="readerSub" class="text-sm text-gray-300 mt-1"></p>
        </div>
        <div class="flex flex-wrap gap-2 items-center">
          <button id="btnPlayPause" class="px-3 py-1 bg-blue-600 rounded w-28 text-center">▶️ Ler</button>
          <button id="btnStop" class="px-3 py-1 bg-red-600 rounded">⏹️ Parar</button>
          <select id="voiceSelect" class="bg-gray-700 text-white rounded px-2 py-1 text-sm"></select>
        </div>
      </div>
      <div class="prose max-w-none text-gray-100 flex-1 overflow-y-auto">
        <pre id="content" class="text-sm leading-6"></pre>
      </div>
    </main>
  </div>

<script>
// Global data store
let bibleData = {};
let currentBook = null;
let currentChapter = null;
let currentFilePath = null;
let isAutoplayEnabled = true; // Controle para a reprodução contínua

function el(tag, attrs={}, txt=''){
  const e = document.createElement(tag);
  for(const k in attrs) e.setAttribute(k, attrs[k]);
  if (txt) e.textContent = txt;
  return e;
}

function loadBooks(){
  const booksDiv = document.getElementById('books');
  booksDiv.innerHTML='';
  const filter = document.getElementById('filterBook');
  const books = Object.keys(bibleData);
  function render(){
    booksDiv.innerHTML='';
    const q = filter.value.toLowerCase();
    books.filter(b=>b.toLowerCase().includes(q)).forEach(b=>{
      const row = el('div',{class:'p-2 rounded cursor-pointer book-item'}, b);
      row.onclick = ()=> selectBook(b);
      booksDiv.appendChild(row);
    });
  }
  filter.oninput = render;
  render();
}

function selectBook(book){
  currentBook = book;
  document.getElementById('readerTitle').textContent = book;
  document.getElementById('readerSub').textContent = '';
  // load chapters
  const chDiv = document.getElementById('chapters');
  chDiv.innerHTML='';
  const chapters = Object.keys(bibleData[book]);
  chapters.forEach(ch=>{
    const r = el('div',{class:'p-2 rounded cursor-pointer chapter-item'}, ch);
    r.onclick = ()=> selectChapter(book, ch);
    chDiv.appendChild(r);
  });
  // clear files and content
  document.getElementById('files').innerHTML='';
  document.getElementById('content').textContent='';
}

function selectChapter(book, chapter){
  currentChapter = chapter;
  document.getElementById('readerSub').textContent = `${book} — ${chapter}`;
  const filesDiv = document.getElementById('files');
  filesDiv.innerHTML='';
  const files = Object.keys(bibleData[book][chapter]);
  files.forEach(f=>{
    const r = el('div',{class:'p-2 rounded cursor-pointer file-item'}, f);
    r.onclick = ()=> loadFile(book, chapter, f);
    filesDiv.appendChild(r);
  });
  document.getElementById('content').textContent='';
}

function loadFile(book, chapter, filename){
  currentBook = book;
  currentChapter = chapter;
  currentFilePath = filename;
  document.getElementById('content').textContent = bibleData[book][chapter][filename];
  document.getElementById('readerTitle').textContent = filename.replace(/\.txt$/i, '');
}

function findNextItem() {
  if (!currentBook || !currentChapter || !currentFilePath) return null;

  const booksList = Object.keys(bibleData);
  const chaptersList = Object.keys(bibleData[currentBook]);
  const filesList = Object.keys(bibleData[currentBook][currentChapter]);

  const currentFileIndex = filesList.indexOf(currentFilePath);

  // 1. Tenta encontrar o próximo arquivo no mesmo capítulo
  if (currentFileIndex < filesList.length - 1) {
    const nextFile = filesList[currentFileIndex + 1];
    return { book: currentBook, chapter: currentChapter, file: nextFile };
  }

  // 2. Se não houver, tenta encontrar o próximo capítulo no mesmo livro
  const currentChapterIndex = chaptersList.indexOf(currentChapter);
  if (currentChapterIndex < chaptersList.length - 1) {
    const nextChapter = chaptersList[currentChapterIndex + 1];
    const nextChapterFiles = Object.keys(bibleData[currentBook][nextChapter]);
    if (nextChapterFiles.length > 0) {
      return { book: currentBook, chapter: nextChapter, file: nextChapterFiles[0] };
    }
  }

  // 3. Se não houver, tenta encontrar o próximo livro
  const currentBookIndex = booksList.indexOf(currentBook);
  if (currentBookIndex < booksList.length - 1) {
    const nextBook = booksList[currentBookIndex + 1];
    const nextBookChapters = Object.keys(bibleData[nextBook]);
    if (nextBookChapters.length > 0) {
      const nextChapter = nextBookChapters[0];
      const nextChapterFiles = Object.keys(bibleData[nextBook][nextChapter]);
      if (nextChapterFiles.length > 0) {
        return { book: nextBook, chapter: nextChapter, file: nextChapterFiles[0] };
      }
    }
  }

  // 4. Chegou ao fim de tudo
  return null;
}

function playNext() {
    const nextItem = findNextItem();
    if (nextItem) {
        selectBook(nextItem.book);
        selectChapter(nextItem.book, nextItem.chapter);
        loadFile(nextItem.book, nextItem.chapter, nextItem.file);
        handlePlayPause(); // Inicia a leitura do novo trecho
    }
}
const synth = window.speechSynthesis;
  let voices = [];
  // Variáveis para controlar o estado da fala
  let currentUtterance = null;
  let originalTextForSpeech = '';

  // Função que popula o seletor de vozes
  function populateVoiceList() {
    const allVoices = synth.getVoices();
    // Detecta se é um dispositivo móvel. A filtragem por 'pt-' só se aplica a desktops.
    const isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);

    const newVoices = isMobile
      ? allVoices // Em dispositivos móveis, mostra todas as vozes
      : allVoices.filter(voice => voice.lang.toLowerCase().includes('pt-')); // Em desktops, filtra por português

    const voiceSelect = document.getElementById('voiceSelect');

    // Armazena o URI da voz atualmente selecionada antes de limpar o dropdown
    let previouslySelectedVoiceURI = null;
    if (voiceSelect.value !== '' && voices.length > 0) { // 'voices' aqui se refere à lista global *antiga*
        const currentVoiceOptionIndex = parseInt(voiceSelect.value, 10);
        if (currentVoiceOptionIndex >= 0 && currentVoiceOptionIndex < voices.length) {
            previouslySelectedVoiceURI = voices[currentVoiceOptionIndex].voiceURI;
        }
    }

    // Atualiza a variável global 'voices' com a nova lista filtrada
    voices = newVoices;

    voiceSelect.innerHTML = ''; // limpar

    // Itera sobre a lista já filtrada de vozes em português
    voices.forEach((voice, i) => {
      const option = document.createElement('option');
      option.textContent = `${voice.name} (${voice.lang})`;
      option.value = i; // O valor da opção é o índice na lista 'voices'
      voiceSelect.appendChild(option);
    });

    // Tenta re-selecionar a voz que estava ativa
    if (previouslySelectedVoiceURI) {
      const newIndex = voices.findIndex(v => v.voiceURI === previouslySelectedVoiceURI);
      if (newIndex !== -1) {
        voiceSelect.selectedIndex = newIndex;
      } else {
        // Se a voz anterior não estiver mais disponível, seleciona a primeira
        voiceSelect.selectedIndex = 0;
      }
    } else {
      // Se nada estava selecionado (primeira carga), seleciona a primeira
      voiceSelect.selectedIndex = 0;
    }
  }

  // A lista de vozes é carregada de forma assíncrona.
  // Verificamos se já está disponível. Se não, esperamos pelo evento onvoiceschanged.
  if (speechSynthesis.onvoiceschanged !== undefined) {
    speechSynthesis.onvoiceschanged = populateVoiceList;
  }
  // Se as vozes já estiverem carregadas na primeira execução, popula a lista imediatamente.
  // Isso é comum em alguns navegadores de desktop.
  if (synth.getVoices().length > 0) { populateVoiceList(); }

  // Função para destacar a palavra/frase durante a fala
  function highlightText(event) {
    const contentEl = document.getElementById('content');
    
    if (event.name === 'word') {
        const start = event.charIndex;
        const end = start + event.charLength;

        // Recria o HTML com a parte destacada
        const before = originalTextForSpeech.substring(0, start);
        const highlighted = originalTextForSpeech.substring(start, end);
        const after = originalTextForSpeech.substring(end);

        contentEl.innerHTML = `${escapeHtml(before)}<span class="highlight-speech">${escapeHtml(highlighted)}</span>${escapeHtml(after)}`;
      }
    };

  // Função principal que gerencia Play/Pause/Resume
  function handlePlayPause() {
    const btn = document.getElementById('btnPlayPause');
    const contentEl = document.getElementById('content');

    if (synth.paused && currentUtterance) {
      // Se estiver pausado, retoma
      synth.resume();
      btn.textContent = '⏸️ Pausar';
    } else if (synth.speaking) {
      // Se estiver falando, pausa
      synth.pause();
      btn.textContent = '▶️ Retomar';
    } else {
      // Se não estiver falando, começa do início
      originalTextForSpeech = contentEl.innerText;
      if (originalTextForSpeech.trim() === '') return;

      synth.cancel(); // Garante que qualquer fala anterior seja interrompida

      currentUtterance = new SpeechSynthesisUtterance(originalTextForSpeech);

      // Configurações da voz e da fala
      const selectedIndex = document.getElementById('voiceSelect').value;
      currentUtterance.voice = voices[selectedIndex];
      currentUtterance.rate = 0.9;
      currentUtterance.pitch = 1.0;
      currentUtterance.volume = 1.0;

      // Adiciona os eventos para o novo utterance
      currentUtterance.onboundary = highlightText;
      currentUtterance.onend = () => {
        contentEl.innerHTML = escapeHtml(originalTextForSpeech);
        btn.textContent = '▶️ Ler';
        currentUtterance = null;
        // Se o autoplay estiver ativo, toca o próximo
        if (isAutoplayEnabled) {
            playNext();
        }
      };

      synth.speak(currentUtterance);
      btn.textContent = '⏸️ Pausar';
    }
  }

  function escapeHtml(unsafe) {
    return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&#039;");
  }

  function handleStop() {
    synth.cancel(); // Isso também aciona o evento 'onend'
    currentUtterance = null;
  }

  // Eventos dos botões
  document.getElementById('btnPlayPause').addEventListener('click', handlePlayPause);
  document.getElementById('btnStop').addEventListener('click', handleStop);

async function main() {
  try {
    const response = await fetch('./data.json');
    if (!response.ok) throw new Error(`Failed to load data.json: ${response.statusText}`);
    bibleData = await response.json();
    loadBooks();
  } catch (e) {
    console.error(e);
    alert('Erro fatal: Não foi possível carregar os dados do comentário. Execute o script de build (node build.js) e verifique se o arquivo data.json existe na pasta public.');
  }
}

main();
</script>
</body>
</html>