<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coment√°rio B√≠blico ‚Äî Navegador Local</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  /* small custom tweaks */
  :root {
    --page-bg: #111827; /* gray-900 */
    --box-bg: #1F2937; /* gray-800 */
    --text-color: #F3F4F6; /* gray-100 */
    --input-bg: #1F2937; /* gray-800 */
    --input-text: #F3F4F6; /* gray-100 */
    --first-color: #077336;
    --second-color: #8C6927;;
    --third-color: #515d64;
    --fourth-color: #634236;
    --fifth-color: #525180;
    --sixth-color: #B52749;
  }

  .day-mode {
    --page-bg: rgb(233, 208, 167);
    --box-bg: rgb(243, 242, 237);
    --text-color: rgb(161, 0, 41);
    --input-bg: #fff;
    --input-text: #000;
  }

   .nature-mode {
    --page-bg: #000000; /* Fundo preto */
    --box-bg: rgba(50, 50, 50, 0.60); /* Cinza escuro com mais de 90% de opacidade */
    /*--text-color: #F1F2C2; /* cor padr√£o de leitura */
    --input-bg: rgba(50, 50, 50, 0.95);
    --input-text: #F1F2C2;

    /* Gradiente de tons */
    --tone-darkest: #085933;
    --tone-darker: #077336;
    --tone-medium: #9ABF4B;
    --tone-light: #CED979;
    --tone-lightest: #e1f2c2;

    --text-color: var(--tone-lightest);
  }

  .gold-mode {
    /* Gradiente de tons */
    --tone-darkest: #614b22;
    --tone-darker: #8C6927;
    --tone-medium: #BF923F;
    --tone-light: #D9B573;
    --tone-lightest: #F2E1C2;
    
    --text-color: var(--tone-lightest);
  }

  .blue-mode {
    /* Gradiente de tons */
    --tone-darkest: #425059;
    --tone-darker: #69828C;
    --tone-medium: #93B3BF;
    --tone-light: #B4CED9;
    --tone-lightest: #D7E3E9;
    
    --text-color: var(--tone-lightest);
  }

  .red-mode {
    /* Gradiente de tons */
    --tone-darker: #592918;
    --tone-medium: #B5654B;
    --tone-light: #D9896A;
    --tone-lightest: #e7c0ae;
    
    --text-color: var(--tone-lightest);
  }

  .purple-mode {
    /* Gradiente de tons */
    --tone-darkest: #592A51;
    --tone-darker: #3E3C7D;
    --tone-medium: #5256A0;
    --tone-light: #8B8ABF;
    --tone-lightest: #b8c3da;
    
    --text-color: var(--tone-lightest);
  }

  .pink-mode {
    /* Gradiente de tons */
    --tone-darkest: #601429;
    --tone-darker: #B52749;
    --tone-medium: #BF215B;
    --tone-light: #D9297B;
    --tone-lightest: #f1b8b8;
    
    --text-color: var(--tone-lightest);
  }

  .diamond-mode{
    --page-bg: #000000; /* Fundo preto */
    --box-bg: rgba(50, 50, 50, 0.60); /* Cinza escuro com mais de 90% de opacidade */
    /*--text-color: #F1F2C2; /* cor padr√£o de leitura */
    --input-bg: rgba(50, 50, 50, 0.95);
    --input-text: #F1F2C2;
  }

   /* Aplica√ß√£o dos tons aos elementos espec√≠ficos */
  .diamond-mode .book-item{
    font-weight: bold;
  }

  .nature-mode #chapters h2,
  .nature-mode .chapter-item {
    color: var(--tone-medium);
  }

  .nature-mode #files h2,
  .nature-mode .file-item {
    color: var(--tone-light);
  }

  .nature-mode #content pre {
    --text-color: var(--tone-lightest);
  }

  /* Aplica√ß√£o dos tons aos elementos espec√≠ficos no tema dourado */  
  .gold-mode #chapters h2,
  .gold-mode .chapter-item {
    color: var(--tone-medium);
  }

  .gold-mode #files h2,
  .gold-mode .file-item {
    color: var(--tone-light);
  }

  .gold-mode #content pre {
    --text-color: var(--tone-lightest);
  }

  /*---------------------------------------*/
  .blue-mode #chapters h2,
  .blue-mode .chapter-item {
    color: var(--tone-medium);
  }

  .blue-mode #files h2,
  .blue-mode .file-item {
    color: var(--tone-light);
  }

  .blue-mode #content pre {
    --text-color: var(--tone-lightest);
  }

  /*---------------------------------------*/
  .red-mode #chapters h2,
  .red-mode .chapter-item {
    color: var(--tone-medium);
  }

  .red-mode #files h2,
  .red-mode .file-item {
    color: var(--tone-light);
  }

  .red-mode #content pre {
    --text-color: var(--tone-lightest);
  }

  /*---------------------------------------*/
  .purple-mode #chapters h2,
  .purple-mode .chapter-item {
    color: var(--tone-medium);
  }

  .purple-mode #files h2,
  .purple-mode .file-item {
    color: var(--tone-light);
  }

  .purple-mode #content pre {
    --text-color: var(--tone-lightest);
  }

  /*---------------------------------------*/
  .pink-mode #chapters h2,
  .pink-mode .chapter-item {
    color: var(--tone-medium);
  }

  .pink-mode #files h2,
  .pink-mode .file-item {
    color: var(--tone-light);
  }

  .pink-mode #content pre {
    --text-color: var(--tone-lightest);
  }

  body { background-color: var(--page-bg); color: var(--text-color); transition: background-color 0.3s, color 0.3s; margin: 0;}
  .box { background-color: var(--box-bg); color: var(--text-color); transition: background-color 0.3s, color 0.3s; }
  .book-item:hover { background: rgba(255,255,255,0.03); }
  .chapter-item:hover { background: rgba(255,255,255,0.03); }
  .file-item:hover { background: rgba(255,255,255,0.03); }
  pre { white-space: pre-wrap; }
  /* Estilo para a frase destacada durante a leitura */
  .highlight-speech {
    background-color: rgba(96, 165, 250, 0.5); /* Azul claro semi-transparente */
    transition: background-color 0.2s ease-in-out;
  }
  /* Estilos para barras de rolagem mais discretas (WebKit) */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }
  ::-webkit-scrollbar-track {
    background: transparent;
  }
  ::-webkit-scrollbar-thumb {
    background-color: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
  }
  ::-webkit-scrollbar-thumb:hover {
    background-color: rgba(255, 255, 255, 0.4);
  }

  #background-layer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    z-index: -1;
  }

  .bg-image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center center;
    background-repeat: no-repeat;
    opacity: 0;
    transition: opacity 1s ease-in-out; /* üåô dura√ß√£o da transi√ß√£o */
    will-change: opacity;
  }
</style>
<body class="font-sans p-4">
  <div id="background-layer">
    <div class="bg-image" id="bg1"></div>
    <div class="bg-image" id="bg2"></div>
  </div>
  <div class="flex flex-col md:flex-row md:h-screen md:max-h-screen gap-4">
    <!-- Coluna de Livros -->
    <div class="box flex-shrink-0 md:flex-none md:w-64 p-4 rounded-lg flex flex-col">
      <h2 id="booksSectionTitle " class="text-xl font-bold mb-4" >Livros</h2>
      <input id="filterBook" placeholder="filtrar livros..." class="w-full p-2 mb-3 rounded" style="background-color: var(--input-bg); color: var(--input-text);" />
      <div id="books" class="space-y-1 overflow-y-auto h-32 md:h-auto md:flex-1"></div>
    </div>
    <!-- Coluna de Cap√≠tulos -->
    <div class="box flex-shrink-0 md:flex-none md:w-64 p-4 rounded-lg flex flex-col">
      <h2 class="text-xl font-bold mb-4" >Cap√≠tulos</h2>
      <div id="chapters" class="space-y-1 overflow-y-auto h-32 md:h-auto md:flex-1"></div>
    </div>
    <!-- Coluna de Trechos -->
    <div class="box flex-shrink-0 md:flex-none md:w-64 p-4 rounded-lg flex flex-col">
      <h2 class="text-xl font-bold mb-4" >Trechos / Arquivos</h2>
      <div id="files" class="space-y-1 overflow-y-auto h-32 md:h-auto md:flex-1"></div>
    </div>

    <!-- √Årea de Leitura (ocupa o resto do espa√ßo) -->
    <main class="box flex-1 p-4 rounded-lg flex flex-col overflow-hidden">
      <div class="flex flex-col sm:flex-row justify-between items-start mb-2 gap-4">
        <div>
          <h2 id="readerTitle" class="text-2xl font-bold" style="color: var(--text-color);">Selecione um trecho</h2>
          <p id="readerSub" class="text-sm mt-1"></p>
        </div>
        <div class="flex flex-wrap gap-2 items-center">
          <button id="btnPlayPause" class="px-3 py-1 bg-blue-600 rounded w-28 text-center">‚ñ∂Ô∏è Ler</button>
          <button id="btnStop" class="px-3 py-1 bg-red-600 rounded">‚èπÔ∏è Parar</button>
          <select id="voiceSelect" class="bg-gray-700 text-white rounded px-2 py-1 text-sm"></select>
          <select id="speedSelect" class="bg-gray-700 text-white rounded px-2 py-1 text-sm">
            <option value="0.5">Lento (0.5x)</option>
            <option value="0.75">0.75x</option>
            <option value="0.9" selected>Padr√£o (0.9x)</option>
            <option value="1">Normal (1x)</option>
            <option value="1.25">1.25x</option>
            <option value="1.5">R√°pido (1.5x)</option>
            <option value="2">2x</option>
          </select>
          <button id="btnMusic" class="px-3 py-1 bg-green-600 rounded w-28 text-center">üéµ</button>
        </div>
        <button id="themeToggle" class="px-3 py-1 bg-gray-600 rounded">Tema</button>
      </div>
      <div class="prose max-w-none flex-1 overflow-y-auto">
        <pre id="content" class="text-sm leading-6"></pre>
      </div>
      <!-- Caixa para exibir vers√≠culos clicados -->
      <div id="verse-display-container" class="box mt-4 p-4 rounded-lg hidden flex-col max-h-64">
          <h3 id="verse-display-title" class="text-lg font-bold mb-2" style="color: var(--text-color);">Texto dos Vers√≠culos</h3>
          <div class="flex-1 overflow-y-auto">
              <pre id="verse-display" class="text-sm leading-6" style="color: var(--text-color);"></pre>
          </div>
      </div>
    </main>
  </div>

  <!-- Player do YouTube oculto -->
  <div id="youtube-player" style="display: none;"></div>

<script>
// Global data store
let bibleData = {};
let currentBook = null;
let currentChapter = null;
let currentFilePath = null;
let isAutoplayEnabled = true; // Controle para a reprodu√ß√£o cont√≠nua
let musicPlayer; // Vari√°vel para o player de m√∫sica do YouTube
let bibleVerseData = {}; // Para armazenar o data_biblia.json
let currentTheme = 'dark'; // come√ßa no modo escuro

function el(tag, attrs={}, txt=''){
  const e = document.createElement(tag);
  for(const k in attrs) e.setAttribute(k, attrs[k]);
  if (txt) e.textContent = txt;
  return e;
}

function loadBooks(){
  const booksDiv = document.getElementById('books');
  booksDiv.innerHTML='';
  const filter = document.getElementById('filterBook');
  const books = Object.keys(bibleData);
  function render(){
    booksDiv.innerHTML='';
    const q = filter.value.toLowerCase();
    books.filter(b=>b.toLowerCase().includes(q)).forEach(b=>{
      let row = el('div',{class:'p-2 rounded cursor-pointer book-item'}, b);
      if(currentTheme == 'diamond'){
        const match = b.match(/^(\d+)\s*-\s*/);
        const bookIndex = match ? parseInt(match[1], 10) : null;
        if (bookIndex < 6)
          row = el('div',{class:'p-2 rounded cursor-pointer book-item',style: 'color:var(--first-color)'}, b);
        else if (bookIndex < 18)
          row = el('div',{class:'p-2 rounded cursor-pointer book-item',style: 'color:var(--second-color)'}, b); 
        else if (bookIndex < 23)
          row = el('div',{class:'p-2 rounded cursor-pointer book-item',style: 'color:var(--third-color)'}, b); 
        else if (bookIndex < 40)
          row = el('div',{class:'p-2 rounded cursor-pointer book-item',style: 'color:var(--fourth-color)'}, b); 
        else if (bookIndex < 44)
          row = el('div',{class:'p-2 rounded cursor-pointer book-item',style: 'color:var(--fifth-color)'}, b); 
        else
          row = el('div',{class:'p-2 rounded cursor-pointer book-item',style: 'color:var(--sixth-color)'}, b); 
      }
      row.onclick = ()=> selectBook(b);
      booksDiv.appendChild(row);
    });
  }
  filter.oninput = render;
  render();
}
let currentBg = 1;

function changeBackgroundSmoothly(newImage) {
  const bg1 = document.getElementById('bg1');
  const bg2 = document.getElementById('bg2');

  // alterna qual est√° vis√≠vel
  const nextBg = currentBg === 1 ? bg2 : bg1;
  const prevBg = currentBg === 1 ? bg1 : bg2;

  // define imagem nova
  nextBg.style.backgroundImage = `url('${newImage}')`;

  // inicia transi√ß√£o
  nextBg.style.opacity = 1;
  prevBg.style.opacity = 0;

  // atualiza refer√™ncia atual
  currentBg = currentBg === 1 ? 2 : 1;
}

function selectBook(book){
  cancelCurrentSpeech(); // üîπ interrompe qualquer fala pendente
  currentBook = book;
  document.getElementById('readerTitle').textContent = book;
  document.getElementById('readerSub').textContent = '';

  
  if(currentTheme == 'diamond'){
    // üîπ Extrai o √≠ndice num√©rico do livro (antes do h√≠fen)
    const match = book.match(/^(\d+)\s*-\s*/);
    const bookIndex = match ? parseInt(match[1], 10) : null;

    const body = document.body;
    body.classList.remove('nature-mode', 'gold-mode', 'blue-mode', 'red-mode', 'purple-mode', 'pink-mode', 'day-mode');
    
    // üîπ Aplica o tema de acordo com o √≠ndice
    if (bookIndex && bookIndex < 6) {
      body.classList.add('nature-mode');
      changeBackgroundSmoothly('diamante verde.jpg');
    } else if(bookIndex && bookIndex < 18){
      body.classList.add('gold-mode');
      changeBackgroundSmoothly('diamante dourado.jpg');
    } else if(bookIndex && bookIndex < 23){
      body.classList.add('blue-mode');
      changeBackgroundSmoothly('diamante azul claro.jpg');
    } else if(bookIndex && bookIndex < 40){
      body.classList.add('red-mode');
      changeBackgroundSmoothly('diamante vermelho claro.jpg');
    } else if(bookIndex && bookIndex < 44){
      body.classList.add('purple-mode');
      changeBackgroundSmoothly('diamante roxo.jpg');
    } else {
      body.classList.add('pink-mode');
      changeBackgroundSmoothly('diamante rosa forte.jpg');
    }

  }

  // load chapters
  const chDiv = document.getElementById('chapters');
  chDiv.innerHTML='';
  const chapters = Object.keys(bibleData[book]);
  chapters.forEach(ch=>{
    const r = el('div',{class:'p-2 rounded cursor-pointer chapter-item'}, ch);
    r.onclick = ()=> selectChapter(book, ch);
    chDiv.appendChild(r);
  });
  // clear files and content
  document.getElementById('files').innerHTML='';
  document.getElementById('content').textContent='';
}

function selectChapter(book, chapter){
  cancelCurrentSpeech(); // üîπ interrompe qualquer fala pendente
  currentChapter = chapter;
  document.getElementById('readerSub').textContent = `${book} ‚Äî ${chapter}`;
  const filesDiv = document.getElementById('files');
  filesDiv.innerHTML='';
  const files = Object.keys(bibleData[book][chapter]);
  files.forEach(f=>{
    const r = el('div',{class:'p-2 rounded cursor-pointer file-item'}, f);
    r.onclick = ()=> loadFile(book, chapter, f);
    filesDiv.appendChild(r);
  });
  document.getElementById('content').textContent='';
}

function loadFile(book, chapter, filename){
  cancelCurrentSpeech(); // üîπ interrompe qualquer fala pendente
  currentBook = book;
  currentChapter = chapter;
  currentFilePath = filename;
  document.getElementById('content').textContent = bibleData[book][chapter][filename];
  document.getElementById('readerTitle').textContent = filename.replace(/\.txt$/i, '');
  fixReferencesSameChapter();
  makeReferencesClickable();
}

function findNextItem() {
  if (!currentBook || !currentChapter || !currentFilePath) return null;

  const booksList = Object.keys(bibleData);
  const chaptersList = Object.keys(bibleData[currentBook]);
  const filesList = Object.keys(bibleData[currentBook][currentChapter]);

  const currentFileIndex = filesList.indexOf(currentFilePath);

  // 1. Tenta encontrar o pr√≥ximo arquivo no mesmo cap√≠tulo
  if (currentFileIndex < filesList.length - 1) {
    const nextFile = filesList[currentFileIndex + 1];
    return { book: currentBook, chapter: currentChapter, file: nextFile };
  }

  // 2. Se n√£o houver, tenta encontrar o pr√≥ximo cap√≠tulo no mesmo livro
  const currentChapterIndex = chaptersList.indexOf(currentChapter);
  if (currentChapterIndex < chaptersList.length - 1) {
    const nextChapter = chaptersList[currentChapterIndex + 1];
    const nextChapterFiles = Object.keys(bibleData[currentBook][nextChapter]);
    if (nextChapterFiles.length > 0) {
      return { book: currentBook, chapter: nextChapter, file: nextChapterFiles[0] };
    }
  }

  // 3. Se n√£o houver, tenta encontrar o pr√≥ximo livro
  const currentBookIndex = booksList.indexOf(currentBook);
  if (currentBookIndex < booksList.length - 1) {
    const nextBook = booksList[currentBookIndex + 1];
    const nextBookChapters = Object.keys(bibleData[nextBook]);
    if (nextBookChapters.length > 0) {
      const nextChapter = nextBookChapters[0];
      const nextChapterFiles = Object.keys(bibleData[nextBook][nextChapter]);
      if (nextChapterFiles.length > 0) {
        return { book: nextBook, chapter: nextChapter, file: nextChapterFiles[0] };
      }
    }
  }

  // 4. Chegou ao fim de tudo
  return null;
}

function cancelCurrentSpeech() {
  if (currentUtterance) {
    currentUtterance.onend = null;
    currentUtterance.onerror = null;
    currentUtterance.onboundary = null;
  }
  synth.cancel();
  isPlaying = false;
  isPausedByUser = false;
  document.getElementById('btnPlayPause').textContent = '‚ñ∂Ô∏è Ler';
}

function playNext() {
    const nextItem = findNextItem();
    if (nextItem) {
        selectBook(nextItem.book);
        selectChapter(nextItem.book, nextItem.chapter);
        loadFile(nextItem.book, nextItem.chapter, nextItem.file);
        handlePlayPause(); // Inicia a leitura do novo trecho
    }
}
const synth = window.speechSynthesis;
let voices = [];
// Vari√°veis para controlar o estado da fala
let speechQueue = [];
let currentChunkIndex = 0;   // √≠ndice do chunk atualmente a ser lido
let spokenTextLength = 0;    // quantidade total de caracteres j√° consumidos (s√≥ incrementa quando um chunk termina)
let currentUtterance = null;
let isPausedByUser = false;
let isPlaying = false;
let originalTextForSpeech = '';
// Fun√ß√£o que popula o seletor de vozes
function populateVoiceList() {
  const allVoices = synth.getVoices();
  const newVoices = allVoices.filter(voice => voice.lang.toLowerCase().includes('pt-'));

  const voiceSelect = document.getElementById('voiceSelect');

  // Armazena o URI da voz atualmente selecionada antes de limpar o dropdown
  let previouslySelectedVoiceURI = null;
  if (voiceSelect.value !== '' && voices.length > 0) { // 'voices' aqui se refere √† lista global *antiga*
      const currentVoiceOptionIndex = parseInt(voiceSelect.value, 10);
      if (currentVoiceOptionIndex >= 0 && currentVoiceOptionIndex < voices.length) {
          previouslySelectedVoiceURI = voices[currentVoiceOptionIndex].voiceURI;
      }
  }

  // Atualiza a vari√°vel global 'voices' com a nova lista filtrada
  voices = newVoices;

  voiceSelect.innerHTML = ''; // limpar

  // Itera sobre a lista j√° filtrada de vozes em portugu√™s
  voices.forEach((voice, i) => {
    const option = document.createElement('option');
    option.textContent = `${voice.name} (${voice.lang})`;
    option.value = i; // O valor da op√ß√£o √© o √≠ndice na lista 'voices'
    voiceSelect.appendChild(option);
  });

  // Tenta re-selecionar a voz que estava ativa
  if (previouslySelectedVoiceURI) {
    const newIndex = voices.findIndex(v => v.voiceURI === previouslySelectedVoiceURI);
    if (newIndex !== -1) {
      voiceSelect.selectedIndex = newIndex;
    } else {
      // Se a voz anterior n√£o estiver mais dispon√≠vel, seleciona a primeira
      voiceSelect.selectedIndex = 0;
    }
  } else {
    // Se nada estava selecionado (primeira carga), seleciona a primeira
    voiceSelect.selectedIndex = 0;
  }
}

populateVoiceList();
if (speechSynthesis.onvoiceschanged !== undefined) {
  speechSynthesis.onvoiceschanged = populateVoiceList;
}

// Fun√ß√£o para destacar a palavra/frase durante a fala (agora ajustada para a fila)
function highlightText(event) {
  const contentEl = document.getElementById('content');
  
  // Alguns navegadores usam 'word', outros usam 'boundary'; adaptamos:
  if (!event || (event.name !== 'word' && event.name !== 'boundary' && event.name !== 'char')) return;

  // event.charIndex √© relativo ao chunk atual
  const start = (typeof event.charIndex === 'number' ? event.charIndex : 0) + spokenTextLength;
  const end = start + (event.charLength || 0);

  const before = originalTextForSpeech.substring(0, start);
  const highlighted = originalTextForSpeech.substring(start, end);
  const after = originalTextForSpeech.substring(end);

  contentEl.innerHTML =
    `${escapeHtml(before)}<span class="highlight-speech">${escapeHtml(highlighted)}</span>${escapeHtml(after)}`;
}

// Nova fun√ß√£o para gerenciar a fila de fala
function speakTextQueue() {
  // Se j√° terminou a fila
  if (currentChunkIndex >= speechQueue.length) {
    isPlaying = false;
    isPausedByUser = false;
    currentUtterance = null;
    
    document.getElementById('btnPlayPause').textContent = '‚ñ∂Ô∏è Ler';
    // limpa destaque
    document.getElementById('content').innerHTML = escapeHtml(originalTextForSpeech);
    // Se o autoplay estiver ativo, toca o pr√≥ximo trecho
    if (isAutoplayEnabled) {
        playNext();
    }
    return;
  }

  // Se o usu√°rio pausou, n√£o iniciar novo utterance
  if (isPausedByUser) {
    isPlaying = false;
    return;
  }

  const textChunk = speechQueue[currentChunkIndex];
  if (!textChunk) {
    isPlaying = false;
    return;
  }

  // cria utterance com o chunk atual (sempre do come√ßo do chunk)
  currentUtterance = new SpeechSynthesisUtterance(textChunk);
  const selectedIndex = document.getElementById('voiceSelect').value;
  const speed = parseFloat(document.getElementById('speedSelect')?.value) || 0.9;
  currentUtterance.voice = voices && voices[selectedIndex] ? voices[selectedIndex] : null;
  currentUtterance.rate = speed;
  currentUtterance.pitch = 1.0;
  currentUtterance.volume = 1.0;

  /*
  // boundary -> usamos para destacar (charIndex relativo ao chunk)
  currentUtterance.onboundary = (ev) => {
    // Alguns navegadores disparam event.name differently; guard clauses j√° na highlightText
    // Repassamos o evento, mas com a garantia de que spokenTextLength est√° correto
    highlightText(ev);
  };*/

  // quando o chunk terminar, avan√ßamos o √≠ndice e atualizamos spokenTextLength
  currentUtterance.onend = () => {
    // Se o evento 'onend' foi acionado por uma pausa do usu√°rio, n√£o fazemos nada.
    if (isPausedByUser) return;

    // s√≥ ap√≥s o chunk terminar inteiramente incrementamos o deslocamento global
    spokenTextLength += textChunk.length; // +1 opcional para separar (o mesmo que usou)
    // L√≥gica corrigida para o c√°lculo do deslocamento (spokenTextLength)
    // Em vez de adivinhar o separador (+1), calculamos a posi√ß√£o exata da pr√≥xima frase.
    const nextChunkIndex = currentChunkIndex;
    if (nextChunkIndex < speechQueue.length) {
      const nextChunk = speechQueue[nextChunkIndex];
      // Encontra o in√≠cio da pr√≥xima frase no texto original, a partir da posi√ß√£o atual.
      spokenTextLength = originalTextForSpeech.indexOf(nextChunk, spokenTextLength);
    } else {
      // Se for a √∫ltima frase, o deslocamento √© o final do texto.
      spokenTextLength = originalTextForSpeech.length;
    }
    currentChunkIndex++;
    // pequena garantia para evitar reentr√¢ncia imediata em alguns navegadores:
    setTimeout(() => {
      speakTextQueue();
    }, 0);
  };

  // Error handling minimamente √∫til
  currentUtterance.onerror = () => {
    // Em caso de erro, tenta avan√ßar para o pr√≥ximo chunk e n√£o travar
    currentChunkIndex++;
    setTimeout(speakTextQueue, 0);
  };

  // Finalmente: fale
  synth.speak(currentUtterance);
  isPlaying = true;
  isPausedByUser = false;
  document.getElementById('btnPlayPause').textContent = '‚è∏Ô∏è Pausar';
}

// --- Play / Pause / Start handler (substitua seu handlePlayPause por esta) ---
function handlePlayPause() {
  const btn = document.getElementById('btnPlayPause');
  const contentEl = document.getElementById('content');

  // Se atualmente est√° pausado (estado interno), queremos retomar: reinicia speakTextQueue
  if (isPausedByUser) {
    // Cancelamos qualquer utterance pendente (garantia) e reiniciamos a fila a partir do chunk atual
    synth.cancel();
    isPausedByUser = false;
    // reinicia a fala a partir do chunk atual (do come√ßo do chunk)
    speakTextQueue();
    return;
  }

  // Se est√° tocando, "pausa" ‚Äî no nosso fluxo vamos cancelar a utterance atual e marcar paused
  if (isPlaying && !isPausedByUser) {
    currentChunkIndex--;
    isPausedByUser = true; // 1. Define a flag PRIMEIRO para evitar a condi√ß√£o de corrida.
    // 2. Desarma o evento onend do utterance atual ANTES de cancelar.
    // Isso garante que o cancelamento n√£o acione o avan√ßo do chunk.
    if (currentUtterance) currentUtterance.onend = null;
    // Cancelamos o synth para interromper imediatamente (alguns navegadores n√£o pausam boundary corretamente)
    synth.cancel(); // 2. Agora cancela. O 'onend' disparado ver√° a flag e n√£o far√° nada.
    isPlaying = false; 
    // Deixamos currentChunkIndex intacto (para que, ao retomar, o chunk atual seja relido do in√≠cio)
    btn.textContent = '‚ñ∂Ô∏è Retomar';
    return;
  }

  // Caso n√£o esteja falando (nem pausado) -> iniciar nova leitura
  originalTextForSpeech = contentEl.innerText || '';
  if (!originalTextForSpeech.trim()) return;

  // reset
  synth.cancel();
  speechQueue = [];
  currentChunkIndex = 0;
  spokenTextLength = 0;
  currentUtterance = null;
  isPausedByUser = false;
  isPlaying = false;

  // Divide o texto em per√≠odos
  const sentences = originalTextForSpeech.match(/[^.!?\n]+[.!?\n]*|[\n]+/g) || [];

  // Agrupa at√© 5 per√≠odos consecutivos em um mesmo chunk
  const groupedChunks = [];
  for (let i = 0; i < sentences.length; i += 5) {
    const group = sentences.slice(i, i + 5).join(' ').trim();
    if (group) groupedChunks.push(group);
  }

  // Atualiza a fila de fala
  speechQueue = groupedChunks;

  // iniciar
  speakTextQueue();
}

function escapeHtml(unsafe) {
  return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&#039;");
}

function handleStop() {
  if(isPlaying)
    cancelCurrentSpeech();
  // Para a leitura de forma segura, evitando que o 'onend' seja acionado indevidamente.
  isPlaying = false;
  isPausedByUser = false; // Garante que o estado de pausa seja limpo.
  speechQueue = [];
  currentChunkIndex = 0;
  spokenTextLength = 0;
  // Desarma o evento onend antes de cancelar para evitar a chamada indesejada ao playNext().
  if (currentUtterance) currentUtterance.onend = null;
  synth.cancel();
  currentUtterance = null;
  document.getElementById('btnPlayPause').textContent = '‚ñ∂Ô∏è Ler';
}

// Eventos dos bot√µes
document.getElementById('btnPlayPause').addEventListener('click', handlePlayPause);
document.getElementById('btnStop').addEventListener('click', handleStop);
document.getElementById('voiceSelect').addEventListener('change', handleStop); // Para a leitura ao trocar de voz
document.getElementById('content').addEventListener('click', handleVerseClick);
document.getElementById('btnMusic').addEventListener('click', toggleMusic);

const themeToggle = document.getElementById('themeToggle');

themeToggle.addEventListener('click', () => {
  const body = document.body;
  console.log('current_theme', currentTheme)
  if (currentTheme === 'dark') {
    body.classList.remove('day-mode', 'nature-mode', 'gold-mode', 'blue-mode', 'red-mode', 'purple-mode', 'pink-mode', 'diamond-mode');
    body.classList.add('day-mode');
    currentTheme = 'day';
    themeToggle.textContent = 'üíé';
    changeBackgroundSmoothly('');
  } else if (currentTheme === 'day') {
    body.classList.remove('day-mode', 'nature-mode','gold-mode', 'blue-mode', 'red-mode', 'purple-mode', 'pink-mode');
    body.classList.add('nature-mode', 'diamond-mode');
    currentTheme = 'diamond';
    themeToggle.textContent = 'üåô';
    changeBackgroundSmoothly('diamante branco.jpg');
    loadBooks();
  } else {;
    body.classList.remove('day-mode', 'nature-mode','gold-mode', 'blue-mode', 'red-mode', 'purple-mode', 'pink-mode', 'diamond-mode');
    currentTheme = 'dark';
    themeToggle.textContent = '‚òÄÔ∏è';
    changeBackgroundSmoothly('');
    loadBooks()
  }
});

function applyInitialTheme() {
  const savedTheme = localStorage.getItem('theme');
  if (savedTheme === 'day') {
    document.body.classList.add('day-mode');
  } // O modo noturno √© o padr√£o, ent√£o n√£o precisa de 'else'
}

// --- L√≥gica para buscar e exibir vers√≠culos ---

const livros_biblia = ["G√™nesis", "√äxodo", "Lev√≠tico", "N√∫meros", "Deuteron√¥mio", "Josu√©", "Ju√≠zes", "Rute", "1 Samuel", "2 Samuel", "1 Reis", "2 Reis", "1 Cr√¥nicas", "2 Cr√¥nicas", "Esdras", "Neemias", "Ester", "J√≥", "Salmos", "Prov√©rbios", "Eclesiastes", "C√¢ntico Dos C√¢nticos", "Isa√≠as", "Jeremias", "Lamenta√ß√µes", "Ezequiel", "Daniel", "Os√©ias", "Joel", "Am√≥s", "Obadias", "Jonas", "Miqu√©ias", "Naum", "Habacuque", "Sofonias", "Ageu", "Zacarias", "Malaquias", "Mateus", "Marcos", "Lucas", "Jo√£o", "Atos", "Romanos", "1 Cor√≠ntios", "2 Cor√≠ntios", "G√°latas", "Ef√©sios", "Filipenses", "Colossenses", "1 Tessalonicenses", "2 Tessalonicenses", "1 Tim√≥teo", "2 Tim√≥teo", "Tito", "Filemom", "Hebreus", "Tiago", "1 Pedro", "2 Pedro", "1 Jo√£o", "2 Jo√£o", "3 Jo√£o", "Judas", "Apocalipse"];

const abreviacoes = [
"Gn","√äx","Lv","Nm","Dt","Js","Jz","Rt","1 Sm","2 Sm","1 Rs","2 Rs","1 Cr","2 Cr","Ed","Ne","Et","J√≥",
"Sl","Pv","Ec","Ct","Is","Jr","Lm","Ez","Dn","Os","Jl","Am","Ob","Jn","Mq","Na","Hc","Sf","Ag","Zc","Ml",
"Mt","Mc","Lc","Jo","At","Rm","1 Co","2 Co","Gl","Ef","Fp","Cl","1 Ts","2 Ts","1 Tm","2 Tm","Tt","Fm","Hb","Tg",
"1 Pe","2 Pe","1 Jo","2 Jo","3 Jo","Jd","Ap"
];

// Mapa para buscar √≠ndice por nome ou abrevia√ß√£o
const livroMap = {};
livros_biblia.forEach((nome, i) => {
  livroMap[nome.toLowerCase()] = i + 1;
  livroMap[abreviacoes[i].toLowerCase()] = i + 1;
});


// Gera o regex a partir da lista de livros
const verseRegex = new RegExp(`(?<!\\w)(${[...livros_biblia, ...abreviacoes].join('|')})\\s+(\\d+)\\.(\\d+(?:(?:,|-)\\d+)*)`, 'gi');

function fixReferencesSameChapter() {
  const contentEl = document.getElementById('content');
  let html = contentEl.textContent; // Usar textContent para evitar problemas com HTML j√° existente
  
  // 1. Expande as refer√™ncias abreviadas como "cap. 1.23"
  if (currentBook) {
    // Remove o prefixo num√©rico (ex: "01 - G√™nesis" -> "G√™nesis")
    const bookNameOnly = currentBook.replace(/^\d+\s*-\s*/, '');

    // Regex para encontrar "cap. 1.2", "cap. 1.2-3", "cap. 1.2,4", etc.
    const sameChapterRegex = /\b(?:cap\.|cap√≠tulo)\s+(\d+\.\d+(?:[,-]\d+)*)/gi;

    html = html.replace(sameChapterRegex, (match, versePart) => {
      // Reconstr√≥i a refer√™ncia completa, ex: "G√™nesis 1.23"
      // Esta string ser√° ent√£o capturada pelo verseRegex no pr√≥ximo passo.
      return `${bookNameOnly} ${versePart}`;
    });
  }

  contentEl.innerHTML = html;
}

function expandAbbreviatedReferences(text) {
    // Regex para encontrar uma refer√™ncia completa (com livro) ou uma abreviada (s√≥ cap√≠tulo.vers√≠culo)
    // Grupo 1: Nome do livro (opcional)
    // Grupo 2: Refer√™ncia de cap√≠tulo.vers√≠culo
    const fullOrAbbrRegex = new RegExp(`(?:(?<!\\w)(${[...livros_biblia, ...abreviacoes].join('|')})\\s+)?(\\d+\\.(\\d+(?:(?:,|-)\\d+)*))`, 'gi');
    
    let lastBook = '';
    
    return text.replace(fullOrAbbrRegex, (match, book, verseRef) => {
        if (book) {
            // Se a refer√™ncia tem um nome de livro, armazena-o
            lastBook = book;
            return match; // Retorna a refer√™ncia completa como est√°
        } else if (lastBook) {
            // Se n√£o tem livro, mas temos um livro anterior guardado, expande a refer√™ncia
            return `${lastBook} ${verseRef}`;
        }
        // Se n√£o tem livro e nunca encontramos um, retorna o trecho como est√° (ex: um n√∫mero de vers√£o de software)
        return match;
    });
}

function makeReferencesClickable() {
  const contentEl = document.getElementById('content');
  let html = contentEl.textContent; // Usar textContent para evitar problemas com HTML j√° existente

  html = expandAbbreviatedReferences(html);
  
  // Substitui as refer√™ncias por links clic√°veis
  html = html.replace(verseRegex, (match) => {
      return `<a href="#" class="verse-link text-blue-400 hover:underline" data-ref="${match}">${match}</a>`;
  });

  contentEl.innerHTML = html;
}

async function handleVerseClick(event) {
    if (event.target.classList.contains('verse-link')) {
        event.preventDefault();
        const ref = event.target.dataset.ref;
        
        const verseDisplayContainer = document.getElementById('verse-display-container');
        const verseDisplay = document.getElementById('verse-display');
        const verseDisplayTitle = document.getElementById('verse-display-title');
        
        verseDisplay.textContent = 'Buscando...';
        // Reseta o t√≠tulo para o padr√£o ao iniciar uma nova busca
        verseDisplayTitle.textContent = 'Texto dos Vers√≠culos';
        verseDisplayContainer.classList.remove('hidden');
        verseDisplayContainer.classList.add('flex');

        const text = await fetchVerseText(ref);
        verseDisplay.textContent = text || `Refer√™ncia n√£o encontrada: ${ref}`;

        if (text && !text.includes('n√£o encontrado') && !text.includes('inv√°lida')) {
            verseDisplayTitle.textContent = `Texto dos Vers√≠culos ‚Äî ${ref}`;
        }
    }
}

function fetchVerseText(ref) {
  // Parse da refer√™ncia: Ex: "G√™nesis 1:1-3"
  // Regex atualizado para parsear a refer√™ncia completa, incluindo listas com v√≠rgulas.
  const parsingRegex = new RegExp(`^(${[...livros_biblia, ...abreviacoes].join('|')})\\s+(\\d+)\\.((?:\\d+(?:(?:,|-)\\d+)*))$`, 'i');
  const match = ref.match(parsingRegex);

  if (!match) return `Refer√™ncia inv√°lida: "${ref}"`;

  let [, bookName, chapterNum, versesPart] = match;
  const verseList = versesPart.split(',');

  // 1. Encontrar a chave correta do livro em bibleVerseData (ex: "01 - G√™nesis")
  const bookIndex = livroMap[bookName.toLowerCase()];
  bookName = livros_biblia[bookIndex - 1];
  const bookKey = Object.keys(bibleVerseData).find(k => k.startsWith(String(bookIndex).padStart(2, '0')));
  if (!bookKey || !bibleVerseData[bookKey]) {
      console.error(`Chave do livro n√£o encontrada para: ${bookName}`);
      return null;
  }

  // 2. Encontrar a chave correta do cap√≠tulo (ex: "001 - CAP√çTULO 1")
  const chapterKey = Object.keys(bibleVerseData[bookKey]).find(k => {
      const num = k.split(' ')[0];
      return parseInt(num, 10) === parseInt(chapterNum, 10);
  });
  console.log('bookKey:', bookKey);
  console.log('chapterKey:', chapterKey);
  console.log('bibleVerseData:', [bookKey][chapterKey]);
  if (!chapterKey || !bibleVerseData[bookKey][chapterKey]) {
      console.error(`Chave do cap√≠tulo n√£o encontrada para: ${chapterNum} em ${bookKey}`);
      return null;
  }

  const chapterData = bibleVerseData[bookKey][chapterKey];
  let concatenatedText = '';

  // Fun√ß√£o auxiliar para buscar um √∫nico vers√≠culo
  const getVerse = (verseNum) => {
    const verseFileName = `${String(verseNum)}.txt`;
    if (chapterData[verseFileName]) {
      return `[${verseNum}] ${chapterData[verseFileName]}\n`;
    }
    return `[${verseNum}] -- Vers√≠culo n√£o encontrado --\n`;
  };

  // 3. L√≥gica atualizada para buscar os vers√≠culos (intervalos e listas)
  verseList.forEach(verseItem => {
    if (verseItem.includes('-')) {
      // √â um intervalo, como "20-25"
      const [start, end] = verseItem.split('-').map(Number);
      for (let i = start; i <= end; i++) {
        concatenatedText += getVerse(i);
      }
    } else {
      // √â um √∫nico vers√≠culo, como "5" ou "31"
      const verseNum = parseInt(verseItem, 10);
      concatenatedText += getVerse(verseNum);
    }
  });

  return concatenatedText.trim();
}

// --- L√≥gica da M√∫sica de Fundo (YouTube) ---

// 1. Esta fun√ß√£o cria o <iframe> e o player do YouTube
//    depois que o c√≥digo da API √© baixado.
function onYouTubeIframeAPIReady() {
  musicPlayer = new YT.Player('youtube-player', {
    height: '0',
    width: '0', 
    playerVars: {
      // Para tocar uma playlist, usamos 'listType' e 'list'
      'listType': 'playlist',
      // Este √© o ID da sua playlist
      'list': 'PLEpUe48oZgzbYuBdeg44ogoyraQiKNPB2',
      'playsinline': 1
    }
  });
}

// 2. Fun√ß√£o para controlar a reprodu√ß√£o da m√∫sica
function toggleMusic() {
  if (!musicPlayer || typeof musicPlayer.getPlayerState !== 'function') {
    console.log("Player de m√∫sica ainda n√£o est√° pronto.");
    return;
  }
  const playerState = musicPlayer.getPlayerState();
  const btnMusic = document.getElementById('btnMusic');

  if (playerState === YT.PlayerState.PLAYING) {
    musicPlayer.pauseVideo();
    btnMusic.textContent = 'üéµ';
  } else {
    musicPlayer.playVideo();
    btnMusic.textContent = 'üîá';
  }
}

async function main() {
  try {
    const response = await fetch('./data.json');
    if (!response.ok) throw new Error(`Failed to load data.json: ${response.statusText}`);
    bibleData = await response.json();
    
    // Carrega os dados da b√≠blia para os vers√≠culos
    try {
        const bibleResponse = await fetch('./data_biblia.json');
        if (bibleResponse.ok) {
            bibleVerseData = await bibleResponse.json();
        } else {
            console.warn('data_biblia.json n√£o encontrado. A funcionalidade de clique em vers√≠culos estar√° desativada.');
        }
    } catch (e) {
        console.warn('Erro ao carregar data_biblia.json:', e);
    }
    applyInitialTheme();
    loadBooks();
  } catch (e) {
    console.error(e);
    alert('Erro fatal: N√£o foi poss√≠vel carregar os dados do coment√°rio. Execute o script de build (node build.js) e verifique se o arquivo data.json existe na pasta public.');
  }
}

// Carrega a API do IFrame Player do YouTube de forma ass√≠ncrona.
const tag = document.createElement('script');
tag.src = "https://www.youtube.com/iframe_api";
const firstScriptTag = document.getElementsByTagName('script')[0];
firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

main();
</script>

</body>
</html>